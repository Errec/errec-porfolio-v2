// Utility functions for throttle and debounce
const debounce = (func, wait, options = {}) => {
    let timeout, lastCall = 0;
    const { leading = false, trailing = true, maxWait } = options;

    const later = (context, args) => {
        const last = Date.now() - lastCall;
        if (last < wait && last >= 0) {
            timeout = setTimeout(later, wait - last, context, args);
        } else {
            timeout = null;
            if (trailing && (!leading || maxWait)) {
                func.apply(context, args);
            }
        }
    };

    return function(...args) {
        lastCall = Date.now();
        const shouldCall = leading && !timeout;
        if (!timeout) {
            timeout = setTimeout(later, wait, this, args);
        }
        if (shouldCall) {
            func.apply(this, args);
        }
    };
};

const throttle = (func, wait, options = {}) => {
    return debounce(func, wait, { ...options, maxWait: wait });
};

// Parallax background effect
const parallaxAboutBg = () => {
    const aboutImage = document.getElementById("about-parallax-img");
    const aboutSection = document.getElementById("about");

    const handleScroll = () => {
        const scrollPosition = window.scrollY + window.innerHeight - aboutSection.clientHeight / 1.2;
        if (scrollPosition > aboutSection.offsetTop) {
            aboutImage.style.transform = "translate3d(0, -100%, 0)";
            window.removeEventListener("scroll", handleScroll);
        }
    };

    window.addEventListener("scroll", handleScroll);
};

// Animate pin
const animatePin = () => {
    const footerPin = document.getElementById("footer-pin");

    const handleScroll = debounce(() => {
        const scrolledToBottom = window.scrollY + window.innerHeight >= document.documentElement.offsetHeight - 10;
        footerPin.classList.toggle("footer__pin--enter", scrolledToBottom);
    }, 200);

    window.addEventListener("scroll", handleScroll);
};

// Hero animation
const heroAnimation = () => {
    const boxWrapper = document.getElementById("box-wrapper");
    const rightHand = document.getElementById("right-hand");
    const leftHand = document.getElementById("left-hand");
    const heroSection = document.getElementById("hero");

    const handleScroll = throttle(() => {
        const scrollPosition = window.scrollY + window.innerHeight - heroSection.clientHeight / 2.4;
        if (scrollPosition > heroSection.offsetTop) {
            leftHand.classList.add("main-hero__left-hand--move");
            rightHand.classList.add("main-hero__right-hand--move");
            boxWrapper.classList.add("hero__box--state-1");
            window.removeEventListener("scroll", handleScroll);
        }
    }, 250);

    window.addEventListener("scroll", handleScroll);
};

// SVG hover effect
const svgHover = () => {
    const skillsGrid = document.getElementById("skills-grid");

    const handleMouseOver = (event) => {
        if (event.target !== skillsGrid) {
            event.target.classList.remove("main-skills__svg--fill");
        }
    };

    const handleMouseOut = (event) => {
        if (event.target !== skillsGrid) {
            event.target.classList.add("main-skills__svg--fill");
        }
    };

    skillsGrid.addEventListener("mouseover", handleMouseOver);
    skillsGrid.addEventListener("mouseout", handleMouseOut);
};

// Work grid animation
const workGridAnimation = () => {
    const workItems = document.querySelectorAll(".main-work__item");

    const handleScroll = throttle(() => {
        workItems.forEach((item, index) => {
            const isInView = window.scrollY - item.offsetTop > -150 && window.innerWidth < 720;
            if (isInView && item.classList.contains("main-work__item--grow")) {
                item.classList.remove("main-work__item--grow");
                if (index >= workItems.length - 1) {
                    window.removeEventListener("scroll", handleScroll);
                }
            }
        });
    }, 200);

    window.addEventListener("scroll", handleScroll);
};

// Form validation
const checkForm = () => {
    const message = document.getElementById("input-message");
    const email = document.getElementById("input-email");
    const form = document.getElementById("about-form");
    const inputBtn = document.getElementById("input-btn");

    inputBtn.addEventListener("click", () => {
        if (!email.value || !message.value) {
            alert("Can't submit empty email/message");
        } else {
            form.submit();
        }
    });
};

// Scroll to sections
const scrollToSections = () => {
    const sectionsMap = {
        ".header__link-skills": ".main-skills",
        ".header__link-work": ".main-work",
        ".header__link-about": ".main-about",
    };

    Object.entries(sectionsMap).forEach(([linkSelector, sectionSelector]) => {
        const link = document.querySelector(linkSelector);
        const section = document.querySelector(sectionSelector);

        link.addEventListener("click", () => {
            section.scrollIntoView({ behavior: "smooth" });
        });
    });
};

// Initialize all animations
document.addEventListener("DOMContentLoaded", () => {
    parallaxAboutBg();
    animatePin();
    heroAnimation();
    svgHover();
    workGridAnimation();
    checkForm();
    scrollToSections();
});

// Polyfill for smooth scroll behavior (only needed for older browsers)
(() => {
    if (!('scrollBehavior' in document.documentElement.style)) {
        const scrollTo = (element, options) => {
            const startY = window.scrollY;
            const targetY = element.getBoundingClientRect().top + startY;
            const distance = targetY - startY;
            const duration = 468;
            let startTime;

            const animateScroll = (currentTime) => {
                if (!startTime) startTime = currentTime;
                const timeElapsed = currentTime - startTime;
                const nextScrollY = easeInOutQuad(timeElapsed, startY, distance, duration);
                window.scrollTo(0, nextScrollY);

                if (timeElapsed < duration) {
                    requestAnimationFrame(animateScroll);
                } else {
                    window.scrollTo(0, targetY);
                }
            };

            requestAnimationFrame(animateScroll);
        };

        const easeInOutQuad = (t, b, c, d) => {
            t /= d / 2;
            if (t < 1) return c / 2 * t * t + b;
            t--;
            return -c / 2 * (t * (t - 2) - 1) + b;
        };

        window.scrollTo = scrollTo;
        window.scrollBy = (x, y) => scrollTo(document.body, { top: window.scrollY + y, left: window.scrollX + x });
        Element.prototype.scrollIntoView = function(options = { behavior: 'auto' }) {
            if (options.behavior === 'smooth') {
                scrollTo(this, options);
            } else {
                this.scrollIntoView(options);
            }
        };
    }
})();
